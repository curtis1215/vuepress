(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{238:function(t,e,r){"use strict";r.r(e);var a=r(0),s=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("主要通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制")]),t._v(" "),r("p",[t._v("一般，我们会设置Cache-Control的值为“public, max-age=xxx”，表示在xxx秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。")]),t._v(" "),t._m(6),t._v(" "),r("p",[t._v("每次都向服务器验证一下缓存的有效性")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),r("p",[t._v("浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在network面板中各请求的size项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的Etag字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有Etag字段，那么浏览器就会将本次缓存写入硬盘中。")]),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),r("p",[t._v("不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。")]),t._v(" "),r("p",[t._v("重排是由CPU处理的，而重绘是由GPU处理的，CPU的处理效率远不及GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。")]),t._v(" "),t._m(24),t._v(" "),r("p",[t._v("渲染层内的元素布局发生修改，都会导致页面重写排列。")]),t._v(" "),r("p",[t._v("比如：窗口的尺寸发生变化、删除或添加DOM元素；修改了影响元素盒子大小的css属性（width height padding...）")]),t._v(" "),t._m(25),t._v(" "),r("p",[t._v("绘制，所有对元素的视觉表现属性的修改，都会引起重绘。")]),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513044&idx=1&sn=9b8526e9d641b970ee5ddac02dae3c57&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node.js : 我只需要一个店小二"),r("OutboundLink")],1)])]),t._v(" "),r("p",[t._v("node 的核心是事件驱动，通过 loop 去异步处理用户请求，相对于传统的后端服务，他们都是将用户的每个请求分配到异步队列中进行处理。")]),t._v(" "),r("p",[t._v("事件驱动的优势：在高并发 IO 时，不会造成堵塞。")]),t._v(" "),r("p",[t._v("Frond-End(Browser) <- nodejs -> Back-End(Java Server)")]),t._v(" "),t._m(31),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.zhihu.com/question/19653241/answer/15993549",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用 Node.js 的优势和劣势都有哪些？"),r("OutboundLink")],1)])]),t._v(" "),r("p",[t._v("pm2。这是它的官网：pm2.keymetrics.io/")]),t._v(" "),r("p",[t._v("它是一款node.js进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个node.js服务。")]),t._v(" "),r("p",[t._v("也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个node.js服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。")]),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.im/post/5c136bd16fb9a049d37efc47",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端缓存最佳实践"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5b6fa8c86fb9a0099910ac91",target:"_blank",rel:"noopener noreferrer"}},[t._v("网站性能优化实战——从12.67s到1.06s的故事"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5ae081aaf265da0b767d263a",target:"_blank",rel:"noopener noreferrer"}},[t._v("你应该知道的前端——缓存"),r("OutboundLink")],1)]),t._v(" "),r("li",[t._v("《大型网站性能监测、分析与优化》")]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/xianyulaodi/p/5755079.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("【原】雅虎前端优化的35条军规"),r("OutboundLink")],1)])])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"前端性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 前端性能优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"网络传输性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络传输性能优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 网络传输性能优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("重定向→拉取缓存→DNS查询→建立TCP链接→发起请求→接收响应→处理HTML元素→元素加载完成")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("缓存一般分为强缓存和协商缓存，主要区别是：使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 强缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 协商缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"前端缓存方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存方案","aria-hidden":"true"}},[this._v("#")]),this._v(" 前端缓存方案")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("HTML：使用协商缓存")]),this._v(" "),e("li",[this._v("CSS JS Image：使用强缓存，文件名带上 hash 值")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"资源打包压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资源打包压缩","aria-hidden":"true"}},[this._v("#")]),this._v(" 资源打包压缩")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("gulp grunt webpack parcel\n")])]),this._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[this._v("1")]),e("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"图片资源优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片资源优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 图片资源优化")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("不要在HTML里缩放图像")]),t._v(" "),r("li",[t._v("使用雪碧图（CSS Sprite）- "),r("code",[t._v("webpack-spritesmith")])]),t._v(" "),r("li",[t._v("使用字体图标（iconfont）- icomoon")]),t._v(" "),r("li",[t._v("使用WebP - 图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"网络传输性能检测工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络传输性能检测工具","aria-hidden":"true"}},[this._v("#")]),this._v(" 网络传输性能检测工具")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("Page Speed | PageSpeed Insights")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"使用cdn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用cdn","aria-hidden":"true"}},[this._v("#")]),this._v(" 使用CDN")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"页面渲染性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染性能优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 页面渲染性能优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浏览器渲染过程（webkit）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程（webkit）","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器渲染过程（webkit）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("《Webkit技术内幕》")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("浏览器的解释器，是包括在渲染引擎内的，我们常说的Chrome（现在使用的是Blink引擎）和Safari使用的Webkit引擎，Firefox使用的Gecko引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的HTML解释器（渲染时用于构造DOM树）、CSS解释器（渲染时用于合成CSS规则）还有我们的JS解释器。不过后来，由于JS的使用越来越重要，工作越来越繁杂，所以JS解释器也渐渐独立出来，成为了单独的JS引擎，就像众所周知的V8引擎，我们经常接触的Node.js也是用的它。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"dom渲染层与gpu硬件加速"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom渲染层与gpu硬件加速","aria-hidden":"true"}},[this._v("#")]),this._v(" DOM渲染层与GPU硬件加速")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("①浏览器会先获取DOM树并依据样式将其分割成多个独立的渲染层")]),this._v(" "),e("li",[this._v("②CPU将每个层绘制进绘图中")]),this._v(" "),e("li",[this._v("③将位图作为纹理上传至GPU（显卡）绘制")]),this._v(" "),e("li",[this._v("④GPU将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"重排和重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排和重绘","aria-hidden":"true"}},[this._v("#")]),this._v(" 重排和重绘")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"重排-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排-reflow","aria-hidden":"true"}},[this._v("#")]),this._v(" 重排 reflow")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint","aria-hidden":"true"}},[this._v("#")]),this._v(" 重绘 repaint")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"优化策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化策略","aria-hidden":"true"}},[this._v("#")]),this._v(" 优化策略")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("CSS属性读写分离")]),t._v(" "),r("li",[t._v("通过切换class或者style.csstext属性去批量操作元素样式")]),t._v(" "),r("li",[t._v("DOM元素离线更新")]),t._v(" "),r("li",[t._v("将没用的元素设为不可见：visibility: hidden，减少重绘的压力")]),t._v(" "),r("li",[t._v("压缩DOM的深度：少用DOM完成页面样式，多使用伪元素或者box-shadow取代。")]),t._v(" "),r("li",[t._v("图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。")]),t._v(" "),r("li",[t._v("对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。（慎重）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"js-阻塞性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-阻塞性能","aria-hidden":"true"}},[this._v("#")]),this._v(" JS 阻塞性能")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"负载均衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡","aria-hidden":"true"}},[this._v("#")]),this._v(" 负载均衡")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"node-js处理io密集型请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js处理io密集型请求","aria-hidden":"true"}},[this._v("#")]),this._v(" Node.js处理IO密集型请求")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"pm2实现node-js“多线程”"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pm2实现node-js“多线程”","aria-hidden":"true"}},[this._v("#")]),this._v(" pm2实现Node.js“多线程”")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"nginx搭建反向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx搭建反向代理","aria-hidden":"true"}},[this._v("#")]),this._v(" nginx搭建反向代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资料","aria-hidden":"true"}},[this._v("#")]),this._v(" 资料")])}],!1,null,null,null);e.default=s.exports}}]);