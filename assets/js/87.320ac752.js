(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{268:function(t,a,e){"use strict";e.r(a);var r=e(3),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"前端性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[t._v("#")]),t._v(" 前端性能优化")]),t._v(" "),e("h2",{attrs:{id:"网络传输性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络传输性能优化"}},[t._v("#")]),t._v(" 网络传输性能优化")]),t._v(" "),e("blockquote",[e("p",[t._v("重定向 → 拉取缓存 →DNS 查询 → 建立 TCP 链接 → 发起请求 → 接收响应 → 处理 HTML 元素 → 元素加载完成")])]),t._v(" "),e("h3",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),e("blockquote",[e("p",[t._v("缓存一般分为强缓存和协商缓存，主要区别是：使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。")])]),t._v(" "),e("h4",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),e("p",[t._v("主要通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制")]),t._v(" "),e("p",[t._v("一般，我们会设置 Cache-Control 的值为“public, max-age=xxx”，表示在 xxx 秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。")]),t._v(" "),e("h4",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),e("p",[t._v("每次都向服务器验证一下缓存的有效性")]),t._v(" "),e("h4",{attrs:{id:"前端缓存方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存方案"}},[t._v("#")]),t._v(" 前端缓存方案")]),t._v(" "),e("ul",[e("li",[t._v("HTML：使用协商缓存")]),t._v(" "),e("li",[t._v("CSS JS Image：使用强缓存，文件名带上 hash 值")])]),t._v(" "),e("p",[t._v("浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在 network 面板中各请求的 size 项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的 Etag 字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘中。")]),t._v(" "),e("h3",{attrs:{id:"资源打包压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资源打包压缩"}},[t._v("#")]),t._v(" 资源打包压缩")]),t._v(" "),e("blockquote",[e("p",[t._v("网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("gulp grunt webpack parcel\n")])])]),e("h3",{attrs:{id:"图片资源优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片资源优化"}},[t._v("#")]),t._v(" 图片资源优化")]),t._v(" "),e("ul",[e("li",[t._v("不要在 HTML 里缩放图像")]),t._v(" "),e("li",[t._v("使用雪碧图（CSS Sprite）- "),e("code",[t._v("webpack-spritesmith")])]),t._v(" "),e("li",[t._v("使用字体图标（iconfont）- icomoon")]),t._v(" "),e("li",[t._v("使用 WebP - 图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间")])]),t._v(" "),e("h3",{attrs:{id:"网络传输性能检测工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络传输性能检测工具"}},[t._v("#")]),t._v(" 网络传输性能检测工具")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Page Speed | PageSpeed Insights")])])]),t._v(" "),e("h3",{attrs:{id:"使用-cdn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-cdn"}},[t._v("#")]),t._v(" 使用 CDN")]),t._v(" "),e("h2",{attrs:{id:"页面渲染性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染性能优化"}},[t._v("#")]),t._v(" 页面渲染性能优化")]),t._v(" "),e("h3",{attrs:{id:"浏览器渲染过程（webkit）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程（webkit）"}},[t._v("#")]),t._v(" 浏览器渲染过程（webkit）")]),t._v(" "),e("ul",[e("li",[t._v("《Webkit 技术内幕》")])]),t._v(" "),e("blockquote",[e("p",[t._v("浏览器的解释器，是包括在渲染引擎内的，我们常说的 Chrome（现在使用的是 Blink 引擎）和 Safari 使用的 Webkit 引擎，Firefox 使用的 Gecko 引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的 HTML 解释器（渲染时用于构造 DOM 树）、CSS 解释器（渲染时用于合成 CSS 规则）还有我们的 JS 解释器。不过后来，由于 JS 的使用越来越重要，工作越来越繁杂，所以 JS 解释器也渐渐独立出来，成为了单独的 JS 引擎，就像众所周知的 V8 引擎，我们经常接触的 Node.js 也是用的它。")])]),t._v(" "),e("h3",{attrs:{id:"dom-渲染层与-gpu-硬件加速"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom-渲染层与-gpu-硬件加速"}},[t._v("#")]),t._v(" DOM 渲染层与 GPU 硬件加速")]),t._v(" "),e("ul",[e("li",[t._v("① 浏览器会先获取 DOM 树并依据样式将其分割成多个独立的渲染层")]),t._v(" "),e("li",[t._v("②CPU 将每个层绘制进绘图中")]),t._v(" "),e("li",[t._v("③ 将位图作为纹理上传至 GPU（显卡）绘制")]),t._v(" "),e("li",[t._v("④GPU 将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU 就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像")])]),t._v(" "),e("h3",{attrs:{id:"重排和重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排和重绘"}},[t._v("#")]),t._v(" 重排和重绘")]),t._v(" "),e("p",[t._v("不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。")]),t._v(" "),e("p",[t._v("重排是由 CPU 处理的，而重绘是由 GPU 处理的，CPU 的处理效率远不及 GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。")]),t._v(" "),e("h4",{attrs:{id:"重排-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排-reflow"}},[t._v("#")]),t._v(" 重排 reflow")]),t._v(" "),e("p",[t._v("渲染层内的元素布局发生修改，都会导致页面重写排列。")]),t._v(" "),e("p",[t._v("比如：窗口的尺寸发生变化、删除或添加 DOM 元素；修改了影响元素盒子大小的 css 属性（width height padding...）")]),t._v(" "),e("h4",{attrs:{id:"重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[t._v("#")]),t._v(" 重绘 repaint")]),t._v(" "),e("p",[t._v("绘制，所有对元素的视觉表现属性的修改，都会引起重绘。")]),t._v(" "),e("h3",{attrs:{id:"优化策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化策略"}},[t._v("#")]),t._v(" 优化策略")]),t._v(" "),e("ul",[e("li",[t._v("CSS 属性读写分离")]),t._v(" "),e("li",[t._v("通过切换 class 或者 style.csstext 属性去批量操作元素样式")]),t._v(" "),e("li",[t._v("DOM 元素离线更新")]),t._v(" "),e("li",[t._v("将没用的元素设为不可见：visibility: hidden，减少重绘的压力")]),t._v(" "),e("li",[t._v("压缩 DOM 的深度：少用 DOM 完成页面样式，多使用伪元素或者 box-shadow 取代。")]),t._v(" "),e("li",[t._v("图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。")]),t._v(" "),e("li",[t._v("对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。（慎重）")])]),t._v(" "),e("h2",{attrs:{id:"js-阻塞性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-阻塞性能"}},[t._v("#")]),t._v(" JS 阻塞性能")]),t._v(" "),e("h2",{attrs:{id:"负载均衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[t._v("#")]),t._v(" 负载均衡")]),t._v(" "),e("h3",{attrs:{id:"node-js-处理-io-密集型请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js-处理-io-密集型请求"}},[t._v("#")]),t._v(" Node.js 处理 IO 密集型请求")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513044&idx=1&sn=9b8526e9d641b970ee5ddac02dae3c57&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node.js : 我只需要一个店小二"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("node 的核心是事件驱动，通过 loop 去异步处理用户请求，相对于传统的后端服务，他们都是将用户的每个请求分配到异步队列中进行处理。")]),t._v(" "),e("p",[t._v("事件驱动的优势：在高并发 IO 时，不会造成堵塞。")]),t._v(" "),e("p",[t._v("Frond-End(Browser) <- nodejs -> Back-End(Java Server)")]),t._v(" "),e("h3",{attrs:{id:"pm2-实现-node-js-多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pm2-实现-node-js-多线程"}},[t._v("#")]),t._v(" pm2 实现 Node.js“多线程”")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.zhihu.com/question/19653241/answer/15993549",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用 Node.js 的优势和劣势都有哪些？"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("pm2。这是它的官网：pm2.keymetrics.io/")]),t._v(" "),e("p",[t._v("它是一款 node.js 进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个 node.js 服务。")]),t._v(" "),e("p",[t._v("也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个 node.js 服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。")]),t._v(" "),e("h3",{attrs:{id:"nginx-搭建反向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx-搭建反向代理"}},[t._v("#")]),t._v(" nginx 搭建反向代理")]),t._v(" "),e("h2",{attrs:{id:"资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[t._v("#")]),t._v(" 资料")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.im/post/5c136bd16fb9a049d37efc47",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端缓存最佳实践"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/5b6fa8c86fb9a0099910ac91",target:"_blank",rel:"noopener noreferrer"}},[t._v("网站性能优化实战——从 12.67s 到 1.06s 的故事"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/5ae081aaf265da0b767d263a",target:"_blank",rel:"noopener noreferrer"}},[t._v("你应该知道的前端——缓存"),e("OutboundLink")],1)]),t._v(" "),e("li",[t._v("《大型网站性能监测、分析与优化》")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.cnblogs.com/xianyulaodi/p/5755079.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("【原】雅虎前端优化的 35 条军规"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);